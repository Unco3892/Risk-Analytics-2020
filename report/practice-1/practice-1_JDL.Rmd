---
title: "report"
output: html_document
---

# Practical 1: A control chart problem

## a)

```{r, echo = FALSE, message = FALSE, include=FALSE}
source(here::here("scripts/setup.R"))
```


```{r, warning=FALSE, message=FALSE}
waiting <- read_csv(here::here("data/waiting.csv"))
```

*Graph* displays the daily waiting times period that the Data covers. It is difficult to notice any seasonality or cyclic patterns in the extreme waiting times.

```{r, fig.asp=.2}
waiting %>%
  ggplot(aes(Date, Average.Wait.Seconds)) +
  geom_line() +
  geom_point()
```

As shown on *graph* and on *table*, Monday, Tuesday and Wednesday are the days of the week tht present the highests extreme values. We can also notice that even if Friday has the highest average waiting time, its maximum value is the lowest.

```{r}
waiting %>%
  mutate(Weekday=factor(Weekday, levels= c("Monday", 
    "Tuesday", "Wednesday", "Thursday", "Friday"))) %>%
  group_by(Weekday) %>%
  summarize(Min = min(Average.Wait.Seconds),
             Q1 = quantile(Average.Wait.Seconds, .25),
             Avg = mean(Average.Wait.Seconds), 
             Q3 = quantile(Average.Wait.Seconds, .75),
             Max = max(Average.Wait.Seconds))
```

```{r}
waiting %>%
  mutate(Weekday=factor(Weekday, levels= c("Monday", 
    "Tuesday", "Wednesday", "Thursday", "Friday"))) %>%
  ggplot(aes(Average.Wait.Seconds, Weekday)) +
  geom_boxplot() +
  coord_flip() +
  ylab("") +
  xlab("Average waiting time (sec)")
```

## b) 

As the one year period corresponds to $n = 250$, we can deduce the upper control limit, which corresponds to $p = 1-1/n$ and equals to `r p`. 
After scaling this value, we can retrieve the associated quantile or the upper control limit, which corresponds to `r upper_limit`.

```{r}
n <- 250

p <- (1-(1/n))

mean <- mean(waiting$Average.Wait.Seconds)
sd <- sd(waiting$Average.Wait.Seconds)

upper_limit <- qnorm(p, mean, sd)
upper_limit
```

*Graph* suggest that the normal distribution is not appropriate to predict extreme values, the extreme observations tend to diverge strongly from their theorical values under the assumption of a normal distribution. This suggests that the tails are heavy.
```{r}
qqnorm(scale(waiting$Average.Wait.Seconds))
qqline(scale(waiting$Average.Wait.Seconds))
hist(waiting$Average.Wait.Seconds)
```
 
 
Running the Shapiro-Wilk test shows that the hypothesis of normality is rejected at level `r shapiro$p.value`

```{r}
shapiro <- shapiro.test(waiting$Average.Wait.Seconds)
```


## c)
### Block Maxima

The Block Maxima approach divides the dataset into blocks with the same number of observations. Then, for each block we select the observation with the highest value. Looking at the dataset, we can divide the it by months or weekly :

```{r}
plot_all_obs <-waiting %>% 
  ggplot(aes(x = Date, y = Average.Wait.Seconds)) +
  geom_point()

tmp <- data.frame(x=rep(seq(as.Date(0, origin="2017-01-01"),
                            length=36, by="1 month"), 2),
                  y=rnorm(72),
                  category=gl(2,36))

plot_all_obs + geom_vline(xintercept=as.numeric(tmp$x),
                linetype=4, colour="red")
```


```{r}
# per week
tmp <- data.frame(x=rep(seq(as.Date(0, origin="2017-01-01"),
                            length=102, by="1 week"), 2))

plot_all_obs + geom_vline(xintercept=as.numeric(tmp$x),
                linetype=4, colour="red")
```


Looking at the data aggregation per month, week and year we conclude that the best way to break the blocks is per month. So we are going to select the maximum for each block and do our analysis on the maxima. 

```{r}
maxima_monthly <- waiting %>% 
  group_by(year(ymd(Date)), month(ymd(Date))) %>% 
  filter(Average.Wait.Seconds == max(Average.Wait.Seconds))

maxima_weekly <- waiting %>% 
  group_by(year(ymd(Date)), week(ymd(Date))) %>% 
  filter(Average.Wait.Seconds == max(Average.Wait.Seconds))
```


```{r}
waiting %>%
  ggplot(aes(Date, Average.Wait.Seconds)) +
  geom_line() +
  geom_point(aes(Date, Average.Wait.Seconds), data = maxima_monthly, color = "red")
```

```{r}
waiting %>%
  ggplot(aes(Date, Average.Wait.Seconds)) +
  geom_line() +
  geom_point(aes(Date, Average.Wait.Seconds), data = maxima_weekly, color = "red")
```

### Peaks-over-threshold approach

The Peaks-over-threshold approach defines the extreme values as the observations above a certain threshold u. In order to find this threshold, we can use an mrlplot:

```{r,message = FALSE,warning=FALSE}
mrlplot(waiting$Average.Wait.Seconds,umin = min(waiting$Average.Wait.Seconds), umax = max(waiting$Average.Wait.Seconds))

tlim <- c(81,1182)
tcplot(waiting$Average.Wait.Seconds, tlim = c(81,1100), std.err = FALSE)

# we take a threshold of 800
```


```{r,message = FALSE,warning=FALSE}
u1 <- 600

u2 <- 800

waiting$col1 <- cut(waiting$Average.Wait.Seconds,
               breaks = c(-Inf, u1, Inf),
               labels = c("<=u", ">u")) 

waiting$col2 <- cut(waiting$Average.Wait.Seconds,
               breaks = c(-Inf, u2, Inf),
               labels = c("<=u", ">u"))
```


```{r,message = FALSE,warning=FALSE}
waiting %>%
  ggplot() +
  geom_line(aes(Date, Average.Wait.Seconds)) +
  geom_point(aes(Date, Average.Wait.Seconds, color = col1)) +
  scale_colour_manual(values = c('black', 'red')) +
  geom_hline(yintercept = u1,
             linetype = 2,
             colour = "red") +
  guides(color = FALSE)
```



```{r}
waiting %>%
  ggplot() +
  geom_line(aes(Date, Average.Wait.Seconds)) +
  geom_point(aes(Date, Average.Wait.Seconds, color = col2)) +
  scale_colour_manual(values = c('black', 'red')) +
  geom_hline(yintercept = u2,
             linetype = 2,
             colour = "red") +
  guides(color = FALSE)
```

## d)
### Block Maxima

To see what kind of distribution to use, we have to estimate $\xi, $\sigma, and $\mu for the maxima. To do so, we can either do it manually, or use a library to do it.

Monthly :
```{r, warning = FALSE, message = FALSE}
# fitting the GEV to the maxima in order to have the location, scale and shape parameterss
fit_gev_maxima_monthly <- fgev(maxima_monthly$Average.Wait.Seconds)
# evd_profile <- profile(gev_maxima)
# M1JP <- profile2d(fit_evd, evd_profile, which = c("scale", "shape"))
# plot(M1JP)

fit_gev_maxima_monthly
```

```{r}
par(mfrow = c(2,2))
plot(fit_gev_maxima_monthly)
```

```{r}
stats::AIC(fit_gev_maxima)
```

Weekly

```{r, warning = FALSE, message = FALSE}
fit_gev_maxima_weekly <- fgev(maxima_weekly$Average.Wait.Seconds)
fit_gev_maxima_weekly
```

```{r}
par(mfrow = c(2,2))
plot(fit_gev_maxima_weekly)
```

```{r}
AIC(fit_gev_maxima_weekly)
```


### POT
```{r}
# fits the w = x - u to a gpd
fit_pot_u1 <-fpot(waiting$Average.Wait.Seconds, threshold = u1, model = c("gpd"))
fit_pot_u2 <-fpot(waiting$Average.Wait.Seconds, threshold = u2, model = c("gpd"))
```

```{r}
par(mfrow=c(2,2))
plot(fit_pot_u1)
```

```{r}
stats::AIC(fit_pot_u1)
```


```{r}
par(mfrow=c(2,2))
plot(fit_pot_u2)
```

```{r}
stats::AIC(fit_pot_u2)
```


## e) 
### Block Maxima

One year return level corresponds, in our dataset, to 250 days.

```{r}
# return level block maxima:
return_level_maxima <- fit_gev_maxima_monthly$estimate[1] + (fit_gev_maxima_monthly$estimate[2]/fit_gev_maxima_monthly$estimate[3])*(((-log(1-1/250))^-fit_gev_maxima_monthly$estimate[3])-1)

return_level_maxima[[1]]
```

### POT

confidence line
```{r}
n.survivors <- waiting %>%
  filter(Average.Wait.Seconds > u2) %>%
  summarize(n = n()) %>%
  pull(n)

p.survivors <- n.survivors/length(waiting$Average.Wait.Seconds)

confidence_line <- u2 + fit_pot_u2$estimate[1]/fit_pot_u2$estimate[2] * (((1-p)/p.survivors)^-fit_pot_u2$estimate[2]-1)
confidence_line[[1]]
```

```{r}
# test <- waiting %>% 
#   group_by(year(ymd(Date)), week(ymd(Date))) %>%
#   mutate(Q = Average.Wait.Seconds - quantile(Average.Wait.Seconds, .9)) %>%
#   filter(Q > 0)
```

